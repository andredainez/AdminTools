# When you chenge something in this file, do : source ~/.zshrc
# Or open a new tab, or a new shell.

# SET UTF-8 for everything
export LC_CTYPE=en_US.UTF-8
export LANG=en_US.UTF-8


# ZSH -----------
ZSH=$HOME/.oh-my-zsh
ZSH_THEME="robbyrussell"
NOMATCH=1
DISABLE_CORRECTION="true"
DISABLE_UPDATE_PROMPT=true

# ZSH Plugin: zsh-syntax-highlighting --------------
# Install:
# cd ~/.oh-my-zsh/custom/plugins
# git clone git://github.com/zsh-users/zsh-syntax-highlighting.git

# ZSH Plugin: zsh-autosuggestions --------------
# Install:
# git clone git://github.com/tarruda/zsh-autosuggestions ~/.zsh-autosuggestions

# Load oh-my-zsh plugins:
plugins=(git rails heroku brew bundler npm sublime wd zsh-syntax-highlighting history-substring-search grep tmux)

# Load autosuggestions:
source ~/.zsh-autosuggestions/autosuggestions.zsh
# Enable autosuggestions automatically:
zle-line-init() {
    zle autosuggest-start
}

zle -N zle-line-init

# DO NOT USE THIS BLOCKS
# The "-end" says: "place the cursor at the end of the line"
# see: https://unix.stackexchange.com/questions/97843/how-can-i-search-history-with-what-is-already-entered-at-the-prompt-in-zsh
# bindkey '\e[A' history-beginning-search-backward-end
# bindkey '\e[B' history-beginning-search-forward-end
# bindkey '\e[A' history-beginning-search-backward
# bindkey '\e[B' history-beginning-search-forward

# Very powerful: Type anyword, do UP or DOWN and it will search in the history
# Thanks to plugin: history-substring-search
bindkey '^[[A' history-substring-search-up
bindkey '^[[B' history-substring-search-down

# Forward  words
bindkey "\e\e[D" backward-word
# Go end of line
bindkey "\e\e[C" end-of-line
# or if you prefer going word by word to the end:
# bindkey "\e\e[C" forward-word

# use ctrl+t to toggle autosuggestions(hopefully this wont be needed as
# zsh-autosuggestions is designed to be unobtrusive)
bindkey '^T' autosuggest-toggle
export AUTOSUGGESTION_HIGHLIGHT_COLOR=fg=246



# load all oh-my-zsh plugins:
source $ZSH/oh-my-zsh.sh

# / ZSH--------
# -------------------------------------------------------------------------
# -------------------------------------------------------------------------
# -------------------------------------------------------------------------


# trim()
# {
#     trimmed=$1
#     trimmed=${trimmed%% }
#     trimmed=${trimmed## }

#     echo $trimmed
# }


# Alias ---------------------
alias z='zeus'
alias clean_log='find ~/Work -type f -iwholename "*/log/*.log" -exec rm "{}" +'
alias clean_tmp='find ~/Work -type d -iwholename "*/tmp/cache" -exec rm -rf "{}" +'
alias bem='bundle exec rake db:migrate && RAILS_ENV=test bundle exec rake db:migrate'

# Ruby process ----------------
kserver () {
    echo "* Killing Rails servers (rails s)"
    for i in `ps aux | grep -i ruby | grep -i 'rails s' | grep -v grep | awk '{print $2}'`; do
        kill -9 $i
        echo "  - Kill ruby process: $i"
    done
    echo "* Done"

    echo "* Killing Zeus servers"
    for i in `ps aux | grep -i ruby | grep -i server | grep -i zeus | grep '/build/' | grep -v grep | awk '{print $2}'`; do
        kill -9 $i
        echo "  - Kill ruby process: $i"
    done

    echo "* Done"

    echo "* Killing Puma servers"
    for i in `ps aux | grep -i puma | grep -v grep | awk '{print $2}'`; do
        kill -9 $i
        echo "  - Kill puma process: $i"
    done
    echo "* Done"

    echo "* Killing Unicorn servers"
    for i in `ps aux | grep -i unicorn | grep -v grep | awk '{print $2}'`; do
        kill -9 $i
        echo "  - Kill unicorn process: $i"
    done
    echo "* Done"

    echo "* Killing Thin servers"
    for i in `ps aux | grep -i thin | grep -v grep | awk '{print $2}'`; do
        kill -9 $i
        echo "  - Kill thin process: $i"
    done
    echo "* Done"

    return 0;
}

kreact () {
    echo "* Killing React Native process"
    for i in `ps aux | grep -i react-native | grep -v grep | awk '{print $2}'`; do
        kill -9 $i
        echo "  - Kill react process: $i"
    done

    for i in `ps aux | grep -i xcode | grep -v grep | awk '{print $2}'`; do
        kill -9 $i
        echo "  - Kill xcode process: $i"
    done

    echo "* Done"
    return 0;
}

ksidekiq () {
    echo "* Killing Sidekiq process"
    for i in `ps aux | grep -i sidekiq | grep -v grep | awk '{print $2}'`; do
        kill -9 $i
        echo "  - Kill sidekiq process: $i"
    done

    echo "* Done"
    return 0;
}

kruby () {
    echo "* Killing Ruby process"
    for i in `ps aux | grep -i ruby | grep -v grep | awk '{print $2}'`; do
        kill -9 $i
        echo "  - Kill ruby process: $i"
    done
    echo "* Done"

    echo "* Killing Spring process"
    for i in `ps aux | grep -i spring | grep -v grep | awk '{print $2}'`; do
        kill -9 $i
        echo "  - Kill Spring process: $i"
    done
    echo "* Done"

    echo "* Killing Zeus"
    for i in `ps aux | grep 'zeus' | grep -v grep | awk '{print $2}'`; do
        kill -9 $i
        echo "  - Kill ruby process: $i"
    done

    kserver
    ksidekiq

    return 0;
}

kdelayed () {
    echo "* Killing Delayed Job process"
    for i in `ps aux | grep -i delayed_job | grep -v grep | awk '{print $2}'`; do
        kill -9 $i
        echo "  - Kill Delayed Job process: $i"
    done
    echo "* Done"

    return 0;
}

kgulp () {
    echo "* Killing GULP process"
    for i in `ps aux | grep -i gulp | grep -v grep | awk '{print $2}'`; do
        kill -9 $i
        echo "  - Kill Gulp process: $i"
    done
}


kgrunt () {
    echo "* Killing GRUNT process"
    for i in `ps aux | grep -i grunt | grep -v grep | awk '{print $2}'`; do
        kill -9 $i
        echo "  - Kill GRUNT process: $i"
    done
}

kgg () {
  kgulp
  kgrunt
}

# Shortcuts -------------------------------
# Shortcut for runing Ruby server, kill other servers before
bes () {
    str=""
    # This is the hack:
    # $@ is the list of arguments of the functions. Each word is an argument
    # usefull for passing options like -p 4000
    for i in "$@"; do
        str+=" $i"
    done
    str=${str%% } # trim

    echo "-- kserver"
    kserver

    echo "bundle exec rails server -b 0.0.0.0 $str"
    echo "exec rails server -b 0.0.0.0 $str" | xargs bundle
}

# Start Zeus server (kill previous servers)
zs () {
    str=""
    for i in "$@"; do
        str+="$i "
    done

    str=${str%% }

    echo "-- kserver"
    kserver

    echo "-- 'zeus server -b 0.0.0.0 $str'"
    echo "server -b 0.0.0.0 $str" | xargs zeus # OK, use xargs to pass parameters with variables
}

# Lunch Zeus Start
zst () {
    echo "* Zeus start"
    rm -f .zeus.sock
    zeus start
}

# GRUNT ------

gruntt () {
    kgulp
    kgrunt
    grunt
}

gulpp () {
    kgulp
    kgrunt
    gulp
}

start_pg () {
  # pg_ctl -D /usr/local/var/postgres -l /usr/local/var/postgres/server.log stop
  rm /usr/local/var/postgres/postmaster.pid
  pg_ctl -D /usr/local/var/postgres -l /usr/local/var/postgres/server.log start
}


# GIT -------------

# When working on a branch, like "api", do "merge_master" to:
# checkout master
# pull latest master code
# get back on your branch
# merge master into your branch
# THEN: resolve conflicts
merge_master () {
    current_branch=$(git rev-parse --abbrev-ref HEAD)
    echo "Current branch: $current_branch"
    echo "Switching to master..."
    git checkout master && git pull origin master && git checkout $current_branch && git merge master
    echo "Now resolve your conflicts"
}

# Commit in one line
# example:
# $ boom this is my commit content without quotes
boom () {
    str=""
    # This is the hack:
    # $@ is the list of arguments of the functions. Each word is an argument
    for i in "$@"; do
        str+="$i "
    done

    git commit -m "$str"
}


pidfor () {
    str=""
    # This is the hack:
    # $@ is the list of arguments of the functions. Each word is an argument
    # usefull for passing options like -p 4000
    for i in "$@"; do
        str+=" $i"
    done
    str=${str%% } # trim
    str=${str## } # trim

    echo "ps aux | grep -i \"$str\""

    ps aux | grep -i "$str"
}







# -------------------------------------------------------------------------
# -------------------------------------------------------------------------
# -------------------------------------------------------------------------
# -------------------------------------------------------------------------
# ADAPT IT TO YOUR NEEDS:




# RVM and NVM (after PATH)------------
[[ -s "$HOME/.rvm/scripts/rvm" ]] && source "$HOME/.rvm/scripts/rvm"
export PATH="$PATH:$HOME/.rvm/bin" # Add RVM to PATH for scripting

export NVM_DIR="$HOME/.nvm"
[ -s "$NVM_DIR/nvm.sh" ] && . "$NVM_DIR/nvm.sh"  # This loads nvm
